<div dir="rtl">

## תשובה לשאלה 1

**a)** התופעה הזאת נגרמת בגלל Race condition
המעבד סיים לתת זמן מעבד לתהליכון של Runner 4 והמשיך ל-Runner 3
לאחר מכן חזר ל-Runner 4 והצהיר שהוא סיים מקום שלישי.

**b)** התופעה לא תחמיר כיוון שעשינו פעולת סנכרון וקיים מנעול שנועל את כל ה-Class "Racer".
כיוון שזה הוא קטע קריטי, סנכרנו ונעלנו את הקטע קוד בו הוא קובע מי סיים ואיזה מקום הוא.

---

## תשובה לשאלה 2

לא בהכרח
כאשר קובעים עדיפות תהליכון גבוהה אז זה רומז למעבד על עדיפות
מה שכן, הוא לא בהכרח ידייק בדבר, וההפרש האמיתי יורגש לפי המשתנה speed שמוגדר ב-״מתחרים״.

---

## תשובה לשאלה 3

**a)** השיטות להגדרת תהליכונים הם:

1. השיטה הראשונה היא - **implements Runnable**

- יתרון: תומך בהורשה
- חיסרון: יש צורך בלעטוף ב-class Thread כדי להריץ ולממש

2. השיטה השנייה היא - **extends Thread**

- יתרון: שימוש פשוט - קוראים ל-start()
- חיסרון: אי אפשר לעשות הורשה

---

**b)**
כיוון ש-MyThread מממש implements Runnable הוא אינו נחשב חלק ממחלקת Thread כיוון שצריך לעטוף אותו במחלקת Thread (לא קיים בדרך זו את פונקציית .start()).

לכן שורה לאחר מכן אנחנו צריכים ליצור תהליכון שעוטף את MyThread ומכין אותו לשימוש.

</div>